#indent_aware
// python parser and grammar

// keywords begin

and: "('and')" { pink }
as: "('as')" { pink }
assert: "('assert')" { pink }
break: "('break')" { pink }
class: "'class'" { pink }
continue: "('continue')" { pink }
def: "('def')" { pink }
del: "('del')" { pink }
elif: "('elif')" { pink }
else: "('else')" { pink }
except: "('except')" { pink }
False: "('False')" { pink }
finally: "('finally')" { pink }
for: "('for')" { pink }
from: "('from')" { pink }
global: "('global')" { pink }
if: "('if')" { pink }
import: "('import')" { pink }
in: "('in')" { pink }
is: "('is')" { pink }
lambda: "('lambda')" { pink }
None: "('None')" { pink }
nonlocal: "('nonlocal')" { pink }
not: "('not')" { pink }
or: "('or')" { pink }
pass: "('pass')" { pink }
raise: "('raise')" { pink }
return: "('return')" { pink }
True: "('True')" { pink }
try: "('try')" { pink }
while: "('while')" { pink }
with: "('with')" { pink }
yield: "('yield')" { pink }
self: "('self')" { white }
super: "('super')" { purple }
None: "('None')" { pink }

str: "('str')" {
  purple
}
int: "('int')" {
  purple
}
float: "('float')" {
  purple
}
complex: "('complex')" {
  purple
}
list: "('list')" {
  purple
}
tuple: "('tuple')" {
  purple
}
range: "('range')" {
  purple
}
dict: "('dict')" {
  purple
}
set: "('set')" {
  purple
}
frozenset: "('frozenset')" {
  purple
}
bool: "('bool')" {
  purple
}
bytes: "('bytes')" {
  purple
}
bytearray: "('bytearray')" {
  purple
}
memoryview: "('memoryview')" {
  purple
}

// keywords end

// grammar begin
Identifier: "(([a-zA-Z] | '_') ([a-zA-Z0-9] | '_')*)" {

}
IdentifierList: "(Identifier (comma Indentation Identifier)*)" {

}
Where: "(Identifier ('.' Identifier)*)" {

}
WhereList: "(Where (comma Indentation Where)*)" {

}
ImportStatement: "((from Indentation Where Indentation)? import Indentation (asterisk | Where) (Indentation as Indentation Identifier)?)" {

}

SingleLineComment: "('#' (!newline .)*)" {
  gray
}
MultiLineComment: "(StringLiteral2)" {

}
Comment: "(SingleLineComment | MultiLineComment)" {

}

DecLiteral: "('-'? ('0' | ([1-9] [0-9]*)) ('.' [0-9]+)? ([eE] ('+' | '-')? [0-9]*)?)" {
  yellow
}
HexLiteral: "('-'? '0x' ('0' | ([1-9a-fA-F] [0-9a-fA-F]*)))" {
  yellow
}
OctLiteral: "('-'? '0' [0-7]+)" {
  yellow
}
BoolLiteral: "(True | False)" {

}
ImaginaryLiteral: "(DecLiteral 'j')" {
  yellow
}
// CharAtomic will be provided in preset
StringLiteral1: "((double_quote CharAtomic* double_quote) | (single_quote CharAtomic* single_quote))" {
  orange
}
ThreeSingleQuotes: "(single_quote single_quote single_quote)" {

}
ThreeDoubleQuotes: "(double_quote double_quote double_quote)" {

}
StringLiteral2: "((ThreeSingleQuotes (!ThreeSingleQuotes .)* ThreeSingleQuotes) | (ThreeDoubleQuotes (!ThreeDoubleQuotes .)* ThreeDoubleQuotes))" {
  orange
}
StringLiteral: "(StringLiteral2 | StringLiteral1)" {

}
ByteLiteral: "('b' StringLiteral)" {
  orange
}
Literal: "(ImaginaryLiteral | DecLiteral | HexLiteral | OctLiteral | BoolLiteral | StringLiteral | ByteLiteral | None)" {

}

// operations
EQ: "(Expr Indentation '==' Indentation Expr)" {

}
NEQ: "(Expr Indentation '!=' Indentation Expr)" {

}
LE: "(Expr Indentation '<' Indentation Expr)" {

}
GE: "(Expr Indentation '>' Indentation Expr)" {

}
LEQ: "(Expr Indentation '<=' Indentation Expr)" {

}
GEQ: "(Expr Indentation '>=' Indentation Expr)" {

}

ADD: "(Expr Indentation '+' Indentation Expr)" {

}
SUB: "(Expr Indentation '-' Indentation Expr)" {

}
MUL: "(Expr Indentation '*' Indentation Expr)" {

}
DIV: "(Expr Indentation '/' Indentation Expr)" {

}
POW: "(Expr Indentation '**' Indentation Expr)" {

}
FLOOR_DIV: "(Expr Indentation '//' Indentation Expr)" {

}
MOD: "(Expr Indentation '%' Indentation Expr)" {

}
SELF_ADD: "(Expr Indentation '+=' Indentation Expr)" {

}
SELF_SUB: "(Expr Indentation '-=' Indentation Expr)" {

}
SELF_MUL: "(Expr Indentation '*=' Indentation Expr)" {

}
SELF_DIV: "(Expr Indentation '/=' Indentation Expr)" {

}
SELF_FLOOR_DIV: "(Expr Indentation '//=' Indentation Expr)" {

}
SELF_MOD: "(Expr Indentation '%=' Indentation Expr)" {

}
SELF_POW: "(Expr Indentation '**=' Indentation Expr)" {

}

AND: "(Expr Indentation and Indentation Expr)" {

}
OR: "(Expr Indentation or Indentation Expr)" {

}
NOT: "(not Indentation Expr)" {

}

B_AND: "(Expr Indentation '&' Indentation Expr)" {

}
B_OR: "(Expr Indentation '|' Indentation Expr)" {

}
SELF_B_AND: "(Expr Indentation '&=' Indentation Expr)" {

}
SELF_B_OR: "(Expr Indentation '|=' Indentation Expr)" {

}
B_NOT: "('~' Expr)" {

}
XOR: "(Expr Indentation '^' Indentation Expr)" {

}
SELF_XOR: "(Expr Indentation '^=' Indentation Expr)" {

}
LSH: "(Expr Indentation '<<' Indentation Expr)" {

}
RSH: "(Expr Indentation '>>' Indentation Expr)" {

}
SELF_LSH: "(Expr Indentation '<<=' Indentation Expr)" {

}
SELF_RSH: "(Expr Indentation '>>=' Indentation Expr)" {

}

IS: "(Expr Indentation is Indentation Expr)" {

}
IS_NOT: "(Expr Indentation is Indentation not Indentation Expr)" {

}
IN: "(Expr Indentation in Indentation Expr)" {

}
NOT_IN: "(Expr Indentation not Indentation in Indentation Expr)" {

}

Atomic: "(ADD | SUB | MUL | DIV | FLOOR_DIV | MOD | POW | B_AND | B_OR | B_NOT | XOR | LSH | RSH | SELF_ADD | SELF_SUB | SELF_MUL | SELF_DIV | SELF_FLOOR_DIV | SELF_MOD | SELF_POW | SELF_B_AND | SELF_B_OR | SELF_XOR | SELF_LSH | SELF_RSH)" {

}

Comparison: "(EQ | NEQ | LE | GE | LEQ | GEQ | AND | OR | NOT | IS | IS_NOT | IN | NOT_IN)" {

}

// white spaces are not permitted inside any slice, which may cause unexpected syntax error
Slice1: "(Expr)" {

}
Slice2: "((Expr? colon Expr?))" {

}
Slice3: "((Expr? colon Expr? colon Expr?))" {

}
Slice: "(lbracket (Slice3 | Slice2 | Slice1) (comma Indentation (Slice3 | Slice2 | Slice1))* rbracket)" {

}

List: "(lbracket (Expr (comma Indentation Expr)*)? rbracket)" {

}

Tuple: "(lparen (Expr (comma Indentation Expr)*)? rparen)" {

}

Dict: "(lbrace (Literal Indentation Expr (comma Indentation Literal Indentation Expr)*)? rbrace)" {

}

Parameter: "((Identifier single_equal Expr) | Expr | DataType)" {

}

ParameterList: "(lparen (Parameter (comma Indentation Parameter)*)? rparen)" {

}

CALL: "(Identifier ParameterList Slice?)" {
  $0 = green
}
VAR: "(self | super | (Identifier Slice?))" {

}
// solved *print("sb")*
ClassExpr2: "(((ParenExpr | CALL | VAR) '.')* (CALL | VAR))" {
}
StringExpr: "(StringLiteral '.' Identifier ParameterList)" {
  $1 = green
}

Variable: "(ClassExpr2)" {

}
VariableList: "(Variable (comma Indentation Variable)*)" {

}
ParenExpr: "(lparen Expr rparen)" {

}
IDX: "(Expr (lbracket Expr rbracket)+)" {

}
DataTypeExpr: "(List | Tuple | Dict | Range)" {

}
Expr: "(Atomic | Comparison | IDX | DataTypeExpr | Variable | StringExpr | Literal)" {

}

ExprList: "(Expr (comma Indentation Expr)*)" {

}

Assignment: "(VariableList (Indentation '=' Indentation ExprList !lparen)+)" {

}

DelStatement: "(del Indentation Where)" {

}
// assume that exception has only one argument
RaiseStatement: "(raise Expr)" {

}

ReturnStatement: "(return (Indentation ExprList)?)" {

}

Statement: "(ImportStatement | Assignment | GlobalStatement | DelStatement | RaiseStatement | ReturnStatement)" {

}

Argument: "(self | (asterisk? Identifier (single_equal Expr)?))" {

}

ArgumentList: "(lparen (Argument (comma Indentation Argument)*)? rparen)" {

}

GlobalStatement: "(global Indentation IdentifierList)" {

}

// only head here, waiting for full expression with block
DefHead: "(def Indentation Identifier ArgumentList colon)" {
  $2 = cyan
}
ClassHead: "(class Indentation Identifier (lparen WhereList rparen)? colon)" {
  $2 = cyan
}

IfHead: "(if Indentation Expr colon)" {

}
ElifHead: "(elif Indentation Expr colon)" {

}
ElseHead: "(else colon)" {

}
WhileHead: "(while Indentation Expr colon)" {

}
// TODO:
Range: "(range ArgumentList)" {

}
ForHead: "(for Indentation Identifier Indentation in Indentation (Variable | Range) colon)" {

}
TryHead: "(try colon)" {

}
ExceptHead: "(except (Indentation Identifier)? colon)" {

}
FinallyHead: "(finally colon)" {

}

Heads: "(DefHead | ClassHead | IfHead | ElifHead | ElseHead | WhileHead | ForHead | TryHead | ExceptHead | FinallyHead)" {

}

PrimDataType: "(str | int | float | complex | list | tuple | range | dict | set | frozenset | bool | bytes | bytearray | memoryview)" {

}

DataType: "(PrimDataType)" {

}

// grammar end