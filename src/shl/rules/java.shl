// keywords begin
package: "('package')" { pink }
import: "('import')" { pink }
class: "('class')" { pink }
extends: "('extends')" { pink }
implements: "('implements')" { pink }
interface: "('interface')" { pink }

synchronized: "('synchronized')" { pink }
final: "('final')" { pink }
String: "('String')" { blue }
boolean: "('boolean')" { pink }
byte: "('byte')" { pink }
char: "('char')" { pink }
int: "('int')" { pink }
long: "('long')" { pink }
double: "('double')" { pink }
float: "('float')" { pink }
short: "('short')" { pink }
void: "('void')" { pink }
this: "('this')" { pink }
super: "('super')" { pink }
return: "('return')" { pink }
true: "('true')" { pink }
false: "('false')" { pink }

new: "('new')" { pink }
null: "('null')" { pink }
abstract: "('abstract')" { pink }
static: "('static')" { pink }
default: "('default')" { pink }
private: "('private')" { pink }
protected: "('protected')" { pink }
public: "('public')" { pink }
throw: "('throw')" { pink }
throws: "('throws')" { pink }

try: "('try')" { pink }
catch: "('catch')" { pink }
finally: "('finally')" { pink }

for: "('for')" { pink }
do: "('do')" { pink }
while: "('while')" { pink }
break: "('break')" { pink }
continue: "('continue')" { pink }

if: "('if')" { pink }
else: "('else')" { pink }

switch: "('switch')" { pink }
case: "('case')" { pink }

instanceof: "('instanceof')" { pink }

// keywords end

// grammar begin

SingleLineComment: "('//' until_newline)" {
  gray
}
MultiLineComment: "('/*' (!multi_comment_tail .)* '*/')" {
  gray
}
Comment: "(SingleLineComment | MultiLineComment)" {

}

Identifier: "(([a-zA-Z] | '_' | '$') ([a-zA-Z0-9] | '_')*)" {

}

Visibility: "(default | public | protected | private)" {

}

PrimDataType: "(boolean | byte | char | double | float | short | long | int | String)" {

}
PackageDataType: "((Identifier '.')* Identifier)" {
  for (i = 0; -0; 2)
    $i = cyan
}
DataType: "((PrimDataType | PackageDataType))" {

}
ReturnType: "(DataType | void)" {

}


// statements
PackageClass: "(('*' | Identifier) ('.' ('*' | Identifier))*)" {
  cyan
}
ImportStatement: "(import Indent PackageClass semicolon Indent)" {

}

Argument: "(DataType Indent Identifier ('[]')*)" {

}
// revised a bug here
ArgumentList: "(lparen (Argument (comma Indent Argument)*)? rparen)" {

}
// Method checked
Method: "(Visibility (Indent static)? (Indent ReturnType)? Indent Identifier ArgumentList Indent Block)" {
  $-4 = green
}
DecLiteral: "('-'? ('0' | ([1-9] [0-9]*)) ('.' [0-9]+)? ([eE] ('+' | '-') [0-9]*)?)" {
  yellow
}
HexLiteral: "('-'? '0x' ('0' | ([1-9a-fA-F] [0-9a-fA-F]*)))" {
  yellow
}
OctLiteral: "('-'? '0' [0-7]+)" {
  yellow
}
BoolLiteral: "(true | false)" {

}
// CharAtomic will be provided in preset
StringLiteral: "(double_quote CharAtomic* double_quote)" {
  orange
}
CharLiteral: "(single_quote CharAtomic single_quote)" {
  orange
}
Literal: "(DecLiteral | HexLiteral | OctLiteral | BoolLiteral | CharLiteral | StringLiteral | null)" {

}

IDX: "(Expr (lbracket Expr rbracket)+)" {

}

EQ: "(Expr Indent '==' Indent Expr)" {

}
NEQ: "(Expr Indent '!=' Indent Expr)" {

}
LE: "(Expr Indent '<' Indent Expr)" {

}
GE: "(Expr Indent '>' Indent Expr)" {

}
LEQ: "(Expr Indent '<=' Indent Expr)" {

}
GEQ: "(Expr Indent '>=' Indent Expr)" {

}

ADD: "(Expr Indent '+' Indent Expr)" {

}
SUB: "(Expr Indent '-' Indent Expr)" {

}
MUL: "(Expr Indent '*' Indent Expr)" {

}
DIV: "(Expr Indent '/' Indent Expr)" {

}
MOD: "(Expr Indent '%' Indent Expr)" {

}
SELF_ADD: "(Expr Indent '+=' Indent Expr)" {

}
SELF_SUB: "(Expr Indent '-=' Indent Expr)" {

}
SELF_MUL: "(Expr Indent '*=' Indent Expr)" {

}
SELF_DIV: "(Expr Indent '/=' Indent Expr)" {

}
SELF_MOD: "(Expr Indent '%=' Indent Expr)" {

}

INC: "(Identifier '++' | '++' Identifier)" {

}
DEC: "(Identifier '--' | '--' Identifier)" {

}
AND: "(Expr Indent '&&' Indent Expr)" {

}
OR: "(Expr Indent '||' Indent Expr)" {

}
NOT: "('!' Expr)" {

}
B_AND: "(Expr Indent '&' Indent Expr)" {

}
B_OR: "(Expr Indent '|' Indent Expr)" {

}
SELF_B_AND: "(Expr Indent '&=' Indent Expr)" {

}
SELF_B_OR: "(Expr Indent '|=' Indent Expr)" {

}
B_NOT: "('~' Expr)" {

}
XOR: "(Expr Indent '^' Indent Expr)" {

}
SELF_XOR: "(Expr Indent '^=' Indent Expr)" {

}
LSH: "(Expr Indent '<<' Indent Expr)" {

}
RSH: "(Expr Indent '>>' Indent Expr)" {

}
SELF_LSH: "(Expr Indent '<<=' Indent Expr)" {

}
SELF_RSH: "(Expr Indent '>>=' Indent Expr)" {

}
COND: "(Expr Indent question_mark Indent Expr Indent colon Indent Expr)" {

}
PAREN: "(lparen Expr rparen)" {

}

// test here
CALL: "((Expr ('.'))* Identifier ParameterList)" {
  $-2 = green
}
VAR: "((Expr ('.'))* Identifier ParameterList?)" {
  $-1 = green
}
PureAssignment: "(Expr equals Expr)" {

}
CompositeAssignment: "(SELF_ADD | SELF_SUB | SELF_MUL | SELF_DIV | SELF_MOD | SELF_B_AND | SELF_B_OR | SELF_XOR | SELF_LSH | SELF_RSH)" {

}
NewExpr: "(new Indent DataType (lbracket Expr rbracket)* TemplateList? ParameterList?)" {

}
Expr: "(PureAssignment | CompositeAssignment | NewExpr | COND | OR | AND | B_OR | XOR | B_AND | EQ | NEQ | LE | LEQ | GE | GEQ | LSH | RSH | ADD | SUB | MUL | DIV | MOD | NOT | DEREF | ADDR | INC | DEC | IDX | CALL | VAR | PAREN | Literal)" {

}

ParameterList: "(lparen (Expr (comma Indent Expr)*)? rparen)" {

}
TemplateList: "langle  ((DataType) (comma Indent DataType)*)?  rangle" {

}
VariableName: "Identifier" {
  blue
}

Declaration: "(DataType ('[]')* Indent VariableName (equals Expr)? (comma Indent VariableName (equals Expr)?)*)" {

}
DeclarationStatement: "(Declaration semicolon)" {

}
ExprStatement: "(Expr semicolon)" {

}
ReturnStatement: "(return (Indent Expr)? semicolon)" {

}
BreakStatement: "(break semicolon)" {

}
ContinueStatement: "(continue semicolon)" {

}
Statement: "(DeclarationStatement | BreakStatement | ContinueStatement | ExprStatement | ReturnStatement | IfStatement | ForLoop | WhileLoop | DoWhileLoop)" {

}
Block: "(lbrace Indent ((Method | Statement | Comment) Indent)* rbrace)" {

}
Class: "(Visibility Indent class Indent VariableName (Indent extends Indent VariableName)? (Indent implements Indent VariableName (comma Indent VariableName)*)? (Indent throws Indent VariableName (comma Indent VariableName)*)? Indent Block)" {

}
Branch: "(semicolon | Statement | Block)" {

}
ForLoop: "(for Indent lparen Declaration? semicolon Indent Expr? semicolon Indent Expr? rparen Indent Branch)" {

}
WhileLoop: "(while Indent lparen Expr rparen Indent Branch)" {

}
DoWhileLoop: "(do Indent Branch Indent while Indent lparen Expr rparen semicolon)" {

}
IfStatement: "(if Indent lparen Expr rparen Indent Branch (Indent else Indent if Indent lparen Expr rparen Indent Branch)* (Indent else Indent Branch)?)" {

}

// grammar end