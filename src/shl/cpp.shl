#language=cpp
#colorscheme=desert
#debug=true
/*
skip all the space
*/

// markers


// keywords begin
single_comment_head: ('//') { }
multi_comment_head: ('/*') { }
multi_comment_tail: ('*/') { }
hash: ('#') { }
lparen: ('(') { }
rparen: (')') { }
langle: ('<') { }
rangle: ('>') { }
comma: (',') { }
single_quote: ([\']) { }
double_quote: ('\"') { }
single_equal: ('=') { }
double_equal: ('==') { }
backslash: ('\\') { }
newline: ('\n') { }

typedef: ('typedef') { }
pragma: ('pragma') { }
ifdef: ('ifdef') { }
ifndef: ('ifndef') { }
else: ('else') { }
endif: ('endif') { }
include: ('include') { }
using: ('using') { }
namespace: ('namespace') { }
const: ('const') { }
static: ('static') { }
auto: ('auto') { }
return: ('return') { }
while: ('while') { }
if: ('if') { }
inline: ('inline') { }
try: ('try') { }
catch: ('catch') { }
true: ('true') { }
false: ('false') { }
do: ('do') { }
for: ('for') { }
try: ('try') { }
catch: ('catch') { }

// keywords end

// grammars begin
Identifier: (([a-zA-Z] | '_') ([a-zA-Z0-9] | '_')*) {

}

SingleLineComment: (single_comment_head CommentContent) {
  $0 = grey
  $1 = grey
}
MultiLineComment: (multi_comment_head CommentContent multi_comment_tail) {
  $0 = grey
  $1 = grey
  $2 = grey
}
Comment: (SingleLineComment | MultiLineComment) { }

Ifdef: (hash ifdef Identifier) {
  $0 = shallow_yellow
  $1 = shallow_yellow
  $2 = bold cyan
}
Ifndef: (hash ifndef Identifier) {
  $0 = shallow_yellow
  $1 = shallow_yellow
  $2 = bold cyan
}
Else: (hash else) {
  $0 = shallow_yellow
  $1 = shallow_yellow
}
Endif: (hash endif) {
  $0 = shallow_yellow
  $1 = shallow_yellow
}
Define: (hash define Identifier Identifier?) {
  $0 = italic grey
  $1 = italic grey
  $2 = bold grey
  $3 = bold grey
}
until_newline: ((!'\n' .)*) { }
Pragma: (hash pragma until_newline) {
  $0 = shallow_yellow
  $1 = shallow_yellow
  $2 = green
}
IncludeDirectory: (([a-zA-Z0-9] | '_' | '.' | '/')+) {

}
Include: (hash include ((double_quote IncludeDirectory double_quote) | (langle IncludeDirectory rangle))) {

}
Preprocessing: (Include | Ifdef | Ifndef | Else | Endif | Define | Pragma) {

}

UsingNamespace: (using namespace Identifier) {
  $0 = blue
  $2 = cyan
}
UsingAssignment: (using Identifier single_equal QualifiedConstant) {
  $0 = blue
  $2 = purple
  $4 = purple
}
UsingClass: (using QualifiedConstant) {
  $0 = blue
}
UsingStatement: ((UsingNamespace | UsingAssignment | UsingClass) semicolon) { }

Argument: (Identifier) {}
ArgumentList: (lparen Type Argument (comma Type Argument)* rparen) {
  // TODO
}
Parameter: (Expr) {}
ParameterList: (lparen Parameter (comma Parameter)* rparen) {
  // TODO
}

TemplateList: (langle Type (comma Type)* rangle) {
  // TODO
}

AutoType: ((const)? auto (' '? '&')?) {

}

ReturnStatement: (return Expr semicolon) {
  $0 = blue
}

WhileLoop: (while lparen Cond rparen ((Statement | semicolon) | Block)) {

}

DoWhileLoop: (do ((Statement | semicolon) | Block) while lparen Cond rparen semicolon) {

}

ForLoop: (for lparen Declaration semicolon Cond semicolon Expr rparen ((Statement | semicolon) | Block)) {

}

CharAtomic: ((!newline !backslash .) | (backslash [a-z])) {

}
StringLiteral: (double_quote CharAtomic* double_quote) {
  green
}
// alnum
CharLiteral: (single_quote CharAtomic single_quote) {
  blue
}

Zero: ('0') { }
DecDigitHead: ([1-9]) { }
DecDigitBody: ([0-9]) { }
DecLiteral: ((Zero) | (DecDigitHead DecDigitBody*)) { }

HexDigitHead: ('0x') { }
HexDigitBody: ([0-9a-fA-F]) { }
HexLiteral: (HexDigitHead HexDigitBody+) { }

OctDigitHead: (Zero) { }
OctDigitBody: ([0-7]) { }
OctLiteral: (OctDigitHead OctDigitBody+) { }

BoolLiteral: (true | false) { }

Literal: (BoolLiteral | HexLiteral | DecLiteral | OctLiteral | StringLiteral | CharLiteral) {

}

Type: (ManualType | AutoType) {
  // TODO
}

Function: (inline? Type Identifier ArgumentList (semicolon | Statement | Block)) {

}

// simplified version
FunctionCall: (Identifier ParameterList) {

}

Class: (class Identifier ClassBlock semicolon) {

}

Struct: (struct Identifier ClassBlock semicolon) {

}

TypedefStatement: (typedef Type Identifier semicolon) {

}

Declaration: (Type TemplateList? Identifier (single_equal Expr) (comma Identifier single_equal Expr)*) {

}

DeclarationStatement: (Declaration semicolon) {

}

Cond: (Expr) { }

TryCatchStatement: (try (Statement | Block) catch lparen Declaration rparen (Statement | Block)) {

}

IfStatement: (if lparen Cond rparen (semicolon | Statement | Block) (else if lparen Cond rparen (semicolon | Statement | Block))* (else (semicolon | Statement | Block))?) {

}

Statement: (UsingStatement | DeclarationStatement | ReturnStatement | LoopStatement | IfStatement | ExprStatement | TypedefStatement | Class | Struct | Block) {

}

// grammars end