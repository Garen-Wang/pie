// keywords begin
package: "('package')" { }
import: "('import')" { }
class: "('class')" { }
extends: "('extends')" { }
implements: "('implements')" { }
interface: "('interface')" { }

synchronized: "('synchronized')" { }
final: "('final')" { }
String: "('String')" { }
boolean: "('boolean')" { }
byte: "('byte')" { }
char: "('char')" { }
int: "('int')" { }
long: "('long')" { }
double: "('double')" { }
float: "('float')" { }
short: "('short')" { }
void: "('void')" { }
this: "('this')" { }
super: "('super')" { }
return: "('return')" { }

new: "('new')" { }
null: "('null')" { }
abstract: "('abstract')" { }
static: "('static')" { }
default: "('default')" { }
private: "('private')" { }
protected: "('protected')" { }
public: "('public')" { }
throw: "('throw')" { }
throws: "('throws')" { }

try: "('try')" { }
catch: "('catch')" { }
finally: "('finally')" { }

for: "('for')" { }
do: "('do')" { }
while: "('while')" { }
break: "('break')" { }
continue: "('continue')" { }

if: "('if')" { }
else: "('else')" { }

switch: "('switch')" { }
case: "('case')" { }

instanceof: "('instanceof')" { }

// keywords end

// grammar begin

Identifier: "(([a-zA-Z] | '_' | '$') ([a-zA-Z0-9] | '_')*)" {
  black
}

Visibility: "(default | public | protected | private)" {

}

PrimDataType: "(boolean | byte | char | double | float | short | long | int | String)" {

}
PackageDataType: "((Identifier '.')* Identifier)" {

}
DataType: "((PrimDataType | PackageDataType) '[]'*)" {

}
ReturnType: "(DataType | void)" {

}


// statements
PackageClass: "(('*' | Identifier) ('.' ('*' | Identifier))*)" {

}
ImportStatement: "(import Indent PackageClass semicolon)" {

}

Argument: "(DataType Indent Identifier)" {

}
// revised a bug here
ArgumentList: "(lparen (Argument (comma Indent Argument)*)? rparen)" {

}
// Method checked
Method: "(Visibility (Indent static)? (Indent ReturnType)? Indent Identifier ArgumentList Indent Block)" {

}
DecLiteral: "('-'? ('0' | ([1-9] [0-9]*)) ('.' [0-9]+)? ([eE] ('+' | '-') [0-9]*)?)" {

}
HexLiteral: "('-'? '0x' ('0' | ([1-9a-fA-F] [0-9a-fA-F]*)))" {

}
OctLiteral: "('-'? '0' [0-7]+)" {

}
BoolLiteral: "(true | false)" {

}
// CharAtomic will be provided in preset
StringLiteral: "(double_quote CharAtomic* double_quote)" {

}
CharLiteral: "(single_quote CharAtomic single_quote)" {

}
Literal: "(DecLiteral | HexLiteral | OctLiteral | BoolLiteral | CharLiteral | StringLiteral | null)" {

}
EQ: "(Expr Indent '==' Indent Expr)" {

}
NEQ: "(Expr Indent '!=' Indent Expr)" {

}
LE: "(Expr Indent '<' Indent Expr)" {

}
GE: "(Expr Indent '>' Indent Expr)" {

}
LEQ: "(Expr Indent '<=' Indent Expr)" {

}
GEQ: "(Expr Indent '>=' Indent Expr)" {

}

ADD: "(Expr Indent '+' Indent Expr)" {

}
SUB: "(Expr Indent '-' Indent Expr)" {

}
MUL: "(Expr Indent '*' Indent Expr)" {

}
DIV: "(Expr Indent '/' Indent Expr)" {

}
MOD: "(Expr Indent '%' Indent Expr)" {

}
SELF_ADD: "(Expr Indent '+=' Indent Expr)" {

}
SELF_SUB: "(Expr Indent '-=' Indent Expr)" {

}
SELF_MUL: "(Expr Indent '*=' Indent Expr)" {

}
SELF_DIV: "(Expr Indent '/=' Indent Expr)" {

}
SELF_MOD: "(Expr Indent '%=' Indent Expr)" {

}

INC: "(Identifier '++' | '++' Identifier)" {

}
DEC: "(Identifier '--' | '--' Identifier)" {

}
AND: "(Expr Indent '&&' Indent Expr)" {

}
OR: "(Expr Indent '||' Indent Expr)" {

}
NOT: "('!' Expr)" {

}
B_AND: "(Expr Indent '&' Indent Expr)" {

}
B_OR: "(Expr Indent '|' Indent Expr)" {

}
SELF_B_AND: "(Expr Indent '&=' Indent Expr)" {

}
SELF_B_OR: "(Expr Indent '|=' Indent Expr)" {

}
B_NOT: "('~' Expr)" {

}
XOR: "(Expr Indent '^' Indent Expr)" {

}
SELF_XOR: "(Expr Indent '^=' Indent Expr)" {

}
LSH: "(Expr Indent '<<' Indent Expr)" {

}
RSH: "(Expr Indent '>>' Indent Expr)" {

}
U_RSH: "(Expr Indent '>>>' Indent Expr)" {

}
SELF_LSH: "(Expr Indent '<<=' Indent Expr)" {

}
SELF_RSH: "(Expr Indent '>>=' Indent Expr)" {

}
Comparison: "(EQ | NEQ | LEQ | LE | GEQ | GE | AND | OR | NOT)" {

}
Atomic: "(ADD | SUB | MUL | DIV | MOD | INC | DEC | B_AND | B_OR | B_NOT | XOR | LSH | RSH | U_RSH | SELF_ADD | SELF_SUB | SELF_MUL | SELF_DIV | SELF_MOD | SELF_B_AND | SELF_B_OR | SELF_XOR | SELF_LSH | SELF_RSH)" {

}
ParenExpr: "('(' Expr ')')" {

}
ParameterList: "(lparen (Expr (comma Indent Expr)*)? rparen)" {

}
TemplateList: "langle  ((DataType) (comma Indent DataType)*)?  rangle" {

}
NewExpr: "(new Indent DataType TemplateList? ParameterList)" {

}
ClassExpr1: "(NewExpr '.' Identifier ParameterList?)" {

}
// TODO: I think potential bugs will occur here, either ClassExpr1 or ClassExpr2
ClassExpr2: "((Identifier '.')* Identifier ParameterList?)" {

}
Expr: "(Atomic | Comparison | ClassExpr1 | NewExpr | ClassExpr2 | Literal | Identifier | ParenExpr)" {

}
Declaration: "(DataType Indent Identifier equals Expr (comma Indent Identifier equals Expr)*)" {

}
DeclarationStatement: "(Declaration semicolon)" {

}
ExprStatement: "(Expr semicolon)" {

}
ReturnStatement: "(return (Indent Expr)? semicolon)" {

}
Statement: "(DeclarationStatement | ExprStatement | ReturnStatement | IfStatement | ForLoop | WhileLoop | DoWhileLoop)" {

}
Block: "(lbrace Indent ((Method | Statement) Indent)* rbrace)" {

}
Class: "(Visibility Indent class Indent Identifier (Indent extends Indent Identifier)? (Indent implements Indent Identifier (comma Indent Identifier)*)? Indent Block)" {

}
Branch: "(semicolon | Statement | Block)" {

}
ForLoop: "(for Indent lparen Declaration? semicolon Indent Expr? semicolon Indent Expr? rparen Indent Branch)" {

}
WhileLoop: "(while Indent lparen Expr rparen Indent Branch)" {

}
DoWhileLoop: "(do Indent Branch Indent while Indent lparen Expr rparen semicolon)" {

}
IfStatement: "(if Indent lparen Expr rparen Indent Branch (Indent else Indent if Indent lparen Expr rparen Indent Branch)* (Indent else Indent Branch)?)" {

}

// grammar end